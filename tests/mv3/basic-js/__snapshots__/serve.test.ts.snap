// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`serve fs output: 00 manifest.json 1`] = `
Object {
  "action": Object {
    "default_popup": "src/popup.html",
  },
  "background": Object {
    "service_worker": "service-worker-loader.js",
    "type": "module",
  },
  "content_scripts": Array [
    Object {
      "js": Array [
        "assets/content-script-loader.content.js.hash.js",
      ],
      "matches": Array [
        "https://a.com/*",
        "http://b.com/*",
      ],
    },
  ],
  "description": "test extension",
  "host_permissions": Array [
    "https://c.com/*",
  ],
  "manifest_version": 3,
  "name": "Test Extension",
  "version": "1.0.0",
  "web_accessible_resources": Array [
    Object {
      "matches": Array [
        "<all_urls>",
      ],
      "resources": Array [
        "*",
        "**/*",
      ],
      "use_dynamic_url": true,
    },
  ],
}
`;

exports[`serve fs output: 01 output files 1`] = `
Array [
  "assets/content-script-client.js.hash.js",
  "assets/content-script-loader.content.js.hash.js",
  "assets/precontroller.hash.js",
  "manifest.json",
  "service-worker-loader.js",
  "src/content.js.js",
  "src/popup.html",
]
`;

exports[`serve fs output: assets/content-script-client.js.hash.js 1`] = `
"const template = \`
<style>
:host {
  position: fixed;
  z-index: 99999;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow-y: scroll;
  margin: 0;
  background: rgba(0, 0, 0, 0.66);
  --monospace: 'SFMono-Regular', Consolas,
              'Liberation Mono', Menlo, Courier, monospace;
  --red: #ff5555;
  --yellow: #e2aa53;
  --purple: #cfa4ff;
  --cyan: #2dd9da;
  --dim: #c9c9c9;
}

.window {
  font-family: var(--monospace);
  line-height: 1.5;
  width: 800px;
  color: #d8d8d8;
  margin: 30px auto;
  padding: 25px 40px;
  position: relative;
  background: #181818;
  border-radius: 6px 6px 8px 8px;
  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);
  overflow: hidden;
  border-top: 8px solid var(--red);
  direction: ltr;
  text-align: left;
}

pre {
  font-family: var(--monospace);
  font-size: 16px;
  margin-top: 0;
  margin-bottom: 1em;
  overflow-x: scroll;
  scrollbar-width: none;
}

pre::-webkit-scrollbar {
  display: none;
}

.message {
  line-height: 1.3;
  font-weight: 600;
  white-space: pre-wrap;
}

.message-body {
  color: var(--red);
}

.plugin {
  color: var(--purple);
}

.file {
  color: var(--cyan);
  margin-bottom: 0;
  white-space: pre-wrap;
  word-break: break-all;
}

.frame {
  color: var(--yellow);
}

.stack {
  font-size: 13px;
  color: var(--dim);
}

.tip {
  font-size: 13px;
  color: #999;
  border-top: 1px dotted #999;
  padding-top: 13px;
}

code {
  font-size: 13px;
  font-family: var(--monospace);
  color: var(--yellow);
}

.file-link {
  text-decoration: underline;
  cursor: pointer;
}
</style>
<div class=\\"window\\">
  <pre class=\\"message\\"><span class=\\"plugin\\"></span><span class=\\"message-body\\"></span></pre>
  <pre class=\\"file\\"></pre>
  <pre class=\\"frame\\"></pre>
  <pre class=\\"stack\\"></pre>
  <div class=\\"tip\\">
    Click outside or fix the code to dismiss.<br>
    You can also disable this overlay by setting
    <code>server.hmr.overlay</code> to <code>false</code> in <code>vite.config.js.</code>
  </div>
</div>
\`;
const fileRE = /(?:[a-zA-Z]:\\\\\\\\|\\\\/).*?:\\\\d+:\\\\d+/g;
const codeframeRE = /^(?:>?\\\\s+\\\\d+\\\\s+\\\\|.*|\\\\s+\\\\|\\\\s*\\\\^.*)\\\\r?\\\\n/gm;
class ErrorOverlay extends HTMLElement {
  root;
  constructor(err) {
    super();
    this.root = this.attachShadow({ mode: \\"open\\" });
    this.root.innerHTML = template;
    codeframeRE.lastIndex = 0;
    const hasFrame = err.frame && codeframeRE.test(err.frame);
    const message = hasFrame ? err.message.replace(codeframeRE, \\"\\") : err.message;
    if (err.plugin) {
      this.text(\\".plugin\\", \`[plugin:\${err.plugin}] \`);
    }
    this.text(\\".message-body\\", message.trim());
    const [file] = (err.loc?.file || err.id || \\"unknown file\\").split(\`?\`);
    if (err.loc) {
      this.text(\\".file\\", \`\${file}:\${err.loc.line}:\${err.loc.column}\`, true);
    } else if (err.id) {
      this.text(\\".file\\", file);
    }
    if (hasFrame) {
      this.text(\\".frame\\", err.frame.trim());
    }
    this.text(\\".stack\\", err.stack, true);
    this.root.querySelector(\\".window\\").addEventListener(\\"click\\", (e) => {
      e.stopPropagation();
    });
    this.addEventListener(\\"click\\", () => {
      this.close();
    });
  }
  text(selector, text, linkFiles = false) {
    const el = this.root.querySelector(selector);
    if (!linkFiles) {
      el.textContent = text;
    } else {
      let curIndex = 0;
      let match;
      while (match = fileRE.exec(text)) {
        const { 0: file, index } = match;
        if (index != null) {
          const frag = text.slice(curIndex, index);
          el.appendChild(document.createTextNode(frag));
          const link = document.createElement(\\"a\\");
          link.textContent = file;
          link.className = \\"file-link\\";
          link.onclick = () => {
            fetch(\\"/__open-in-editor?file=\\" + encodeURIComponent(file));
          };
          el.appendChild(link);
          curIndex += frag.length + file.length;
        }
      }
    }
  }
  close() {
    this.parentNode?.removeChild(this);
  }
}
const overlayId = \\"vite-error-overlay\\";
if (customElements && !customElements.get(overlayId)) {
  customElements.define(overlayId, ErrorOverlay);
}

console.log(\\"[crx] connecting...\\");
let port;
setupPort();
setInterval(setupPort, 5 * 60 * 1e3);
function setupPort() {
  port?.disconnect();
  port = chrome.runtime.connect({ name: \\"@crx/client\\" });
  port.postMessage({ type: \\"connected\\", url: import.meta.url });
  port.onMessage.addListener(handleMessage);
  port.onDisconnect.addListener(setupPort);
}
function warnFailedFetch(err, path) {
  if (!err.message.match(\\"fetch\\")) {
    console.error(err);
  }
  console.error(\`[hmr] Failed to reload \${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)\`);
}
function cleanUrl(pathname) {
  const url = new URL(pathname, location.toString());
  url.searchParams.delete(\\"direct\\");
  return url.pathname + url.search;
}
let isFirstUpdate = true;
async function handleMessage(payload) {
  switch (payload.type) {
    case \\"connected\\":
      console.log(\`[crx] connected.\`);
      setInterval(() => port.postMessage({ type: \\"ping\\" }), 5000);
      break;
    case \\"update\\":
      notifyListeners(\\"vite:beforeUpdate\\", payload);
      if (isFirstUpdate && hasErrorOverlay()) {
        window.location.reload();
        return;
      } else {
        clearErrorOverlay();
        isFirstUpdate = false;
      }
      payload.updates.forEach((update) => {
        if (update.type === \\"js-update\\") {
          queueUpdate(fetchUpdate(update));
        } else {
          const { path, timestamp } = update;
          const searchUrl = cleanUrl(path);
          const el = Array.from(document.querySelectorAll(\\"link\\")).find((e) => cleanUrl(e.href).includes(searchUrl));
          if (el) {
            const newPath = chrome.runtime.getURL(\`\${searchUrl.slice(1)}\${searchUrl.includes(\\"?\\") ? \\"&\\" : \\"?\\"}t=\${timestamp}\`);
            el.href = new URL(newPath, el.href).href;
          }
          console.log(\`[vite] css hot updated: \${searchUrl}\`);
        }
      });
      break;
    case \\"custom\\": {
      notifyListeners(payload.event, payload.data);
      break;
    }
    case \\"full-reload\\": {
      console.log(\\"[crx] full reload\\");
      setTimeout(() => location.reload(), 1e3);
      break;
    }
    case \\"prune\\":
      notifyListeners(\\"vite:beforePrune\\", payload);
      payload.paths.forEach((path) => {
        const fn = pruneMap.get(path);
        if (fn) {
          fn(dataMap.get(path));
        }
      });
      break;
    case \\"error\\": {
      notifyListeners(\\"vite:error\\", payload);
      const err = payload.err;
      if (enableOverlay) {
        createErrorOverlay(err);
      } else {
        console.error(\`[vite] Internal Server Error
\${err.message}
\${err.stack}\`);
      }
      break;
    }
    default: {
      const check = payload;
      return check;
    }
  }
}
function notifyListeners(event, data) {
  const cbs = customListenersMap.get(event);
  if (cbs) {
    cbs.forEach((cb) => cb(data));
  }
}
const enableOverlay = true;
function createErrorOverlay(err) {
  if (!enableOverlay)
    return;
  clearErrorOverlay();
  document.body.appendChild(new ErrorOverlay(err));
}
function clearErrorOverlay() {
  document.querySelectorAll(overlayId).forEach((n) => n.close());
}
function hasErrorOverlay() {
  return document.querySelectorAll(overlayId).length;
}
let pending = false;
let queued = [];
async function queueUpdate(p) {
  queued.push(p);
  if (!pending) {
    pending = true;
    await Promise.resolve();
    pending = false;
    const loading = [...queued];
    queued = [];
    (await Promise.all(loading)).forEach((fn) => fn && fn());
  }
}
const sheetsMap = /* @__PURE__ */ new Map();
function updateStyle(id, content) {
  let style = sheetsMap.get(id);
  {
    if (style && !(style instanceof HTMLStyleElement)) {
      removeStyle(id);
      style = void 0;
    }
    if (!style) {
      style = document.createElement(\\"style\\");
      style.setAttribute(\\"type\\", \\"text/css\\");
      style.innerHTML = content;
      document.head.appendChild(style);
    } else {
      style.innerHTML = content;
    }
  }
  sheetsMap.set(id, style);
}
function removeStyle(id) {
  const style = sheetsMap.get(id);
  if (style) {
    if (style instanceof CSSStyleSheet) {
      document.adoptedStyleSheets = document.adoptedStyleSheets.filter((s) => s !== style);
    } else {
      document.head.removeChild(style);
    }
    sheetsMap.delete(id);
  }
}
async function fetchUpdate({ path, acceptedPath, timestamp }) {
  const mod = hotModulesMap.get(path);
  if (!mod) {
    return;
  }
  const moduleMap = /* @__PURE__ */ new Map();
  const isSelfUpdate = path === acceptedPath;
  const modulesToUpdate = /* @__PURE__ */ new Set();
  if (isSelfUpdate) {
    modulesToUpdate.add(path);
  } else {
    for (const { deps } of mod.callbacks) {
      deps.forEach((dep) => {
        if (acceptedPath === dep) {
          modulesToUpdate.add(dep);
        }
      });
    }
  }
  const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => {
    return deps.some((dep) => modulesToUpdate.has(dep));
  });
  await Promise.all(Array.from(modulesToUpdate).map(async (dep) => {
    const disposer = disposeMap.get(dep);
    if (disposer)
      await disposer(dataMap.get(dep));
    const [path2, query] = dep.split(\`?\`);
    try {
      const newMod = await import(
        /* @vite-ignore */
        chrome.runtime.getURL(path2.slice(1) + \`.js?import&t=\${timestamp}\${query ? \`&\${query}\` : \\"\\"}\`)
      );
      moduleMap.set(dep, newMod);
    } catch (e) {
      warnFailedFetch(e, dep);
    }
  }));
  return () => {
    for (const { deps, fn } of qualifiedCallbacks) {
      fn(deps.map((dep) => moduleMap.get(dep)));
    }
    const loggedPath = isSelfUpdate ? path : \`\${acceptedPath} via \${path}\`;
    console.log(\`[vite] hot updated: \${loggedPath}\`);
  };
}
const hotModulesMap = /* @__PURE__ */ new Map();
const disposeMap = /* @__PURE__ */ new Map();
const pruneMap = /* @__PURE__ */ new Map();
const dataMap = /* @__PURE__ */ new Map();
const customListenersMap = /* @__PURE__ */ new Map();
const ctxToListenersMap = /* @__PURE__ */ new Map();
const createHotContext = (ownerPath) => {
  if (!dataMap.has(ownerPath)) {
    dataMap.set(ownerPath, {});
  }
  const mod = hotModulesMap.get(ownerPath);
  if (mod) {
    mod.callbacks = [];
  }
  const staleListeners = ctxToListenersMap.get(ownerPath);
  if (staleListeners) {
    for (const [event, staleFns] of staleListeners) {
      const listeners = customListenersMap.get(event);
      if (listeners) {
        customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));
      }
    }
  }
  const newListeners = /* @__PURE__ */ new Map();
  ctxToListenersMap.set(ownerPath, newListeners);
  function acceptDeps(deps, callback = () => {
  }) {
    const mod2 = hotModulesMap.get(ownerPath) || {
      id: ownerPath,
      callbacks: []
    };
    mod2.callbacks.push({
      deps,
      fn: callback
    });
    hotModulesMap.set(ownerPath, mod2);
  }
  const hot = {
    get data() {
      return dataMap.get(ownerPath);
    },
    accept(deps, callback) {
      if (typeof deps === \\"function\\" || !deps) {
        acceptDeps([ownerPath], ([mod2]) => deps && deps(mod2));
      } else if (typeof deps === \\"string\\") {
        acceptDeps([deps], ([mod2]) => callback && callback(mod2));
      } else if (Array.isArray(deps)) {
        acceptDeps(deps, callback);
      } else {
        throw new Error(\`invalid hot.accept() usage.\`);
      }
    },
    acceptDeps() {
      throw new Error(\`hot.acceptDeps() is deprecated. Use hot.accept() with the same signature instead.\`);
    },
    dispose(cb) {
      disposeMap.set(ownerPath, cb);
    },
    prune(cb) {
      pruneMap.set(ownerPath, cb);
    },
    decline() {
    },
    invalidate() {
      location.reload();
    },
    on: (event, cb) => {
      const addToMap = (map) => {
        const existing = map.get(event) || [];
        existing.push(cb);
        map.set(event, existing);
      };
      addToMap(customListenersMap);
      addToMap(newListeners);
    }
  };
  return hot;
};
function injectQuery(url, queryToInject) {
  if (!url.startsWith(\\".\\") && !url.startsWith(\\"/\\")) {
    return url;
  }
  const pathname = url.replace(/#.*$/, \\"\\").replace(/\\\\?.*$/, \\"\\");
  const { search, hash } = new URL(url, \\"http://vitejs.dev\\");
  return \`\${pathname}?\${queryToInject}\${search ? \`&\` + search.slice(1) : \\"\\"}\${hash || \\"\\"}\`;
}

export { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };
"
`;

exports[`serve fs output: assets/content-script-loader.content.js.hash.js 1`] = `
"(function () {
  'use strict';

  (async () => {
    if (\\"\\")
      await import(
        /* @vite-ignore */
        chrome.runtime.getURL(\\"\\")
      );
    await import(
      /* @vite-ignore */
      chrome.runtime.getURL(\\"assets/content-script-client.js.hash.js\\")
    );
    await import(
      /* @vite-ignore */
      chrome.runtime.getURL(\\"src/content.js.js\\")
    );
  })().catch(console.error);

})();
"
`;

exports[`serve fs output: assets/precontroller.hash.js 1`] = `
"setTimeout(() => location.reload(), 100);
"
`;

exports[`serve fs output: service-worker-loader.js 1`] = `
"import 'http://localhost:3000/@crx/client/worker';
import 'http://localhost:3000/src/background.js';
"
`;

exports[`serve fs output: src/content.js.js 1`] = `
"console.log('content script');
"
`;

exports[`serve fs output: src/popup.html 1`] = `
"<!DOCTYPE html>
<html lang=\\"en\\">
  <head>
    <title>Waiting for the extension service worker...</title>
    <script src=\\"/assets/precontroller.hash.js\\"></script>
  </head>
  <body>
    <h1>Waiting for service worker</h1>

    <p>
      If you see this message, it means the service worker has not loaded fully.
    </p>

    <p>
      During development, the service worker reroutes HTML requests to the dev
      server, so this file isn't used unless the extension service worker opens
      a page immediately after a full extension reload, and before the service
      worker takes control of fetch (e.g., in the onInstalled event). In that
      case, this page will continuously reload until the service worker is
      ready, always less than 100 ms.
    </p>

    <p>This page is never added in production.</p>
  </body>
</html>
"
`;
